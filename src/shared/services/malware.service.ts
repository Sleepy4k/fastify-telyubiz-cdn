import fs from "fs/promises";
import sharp from "sharp";
import type { FileCategory } from "../../config/file-categories.config.ts";

export interface MalwareScanResult {
  safe: boolean;
  threats: string[];
  details?: string;
}

export class MalwareService {
  /**
   * Check if file category is binary (should skip text-based checks)
   */
  private isBinaryFileCategory(category: FileCategory | "other"): boolean {
    return ["image", "video", "audio", "archive"].includes(category);
  }

  /**
   * Scan file for potential malware and code injection
   * @param filePath - Path to file to scan
   * @param category - File category to determine scan strategy
   * @returns Scan result with safe status and detected threats
   */
  async scanFile(
    filePath: string,
    category: FileCategory | "other",
  ): Promise<MalwareScanResult> {
    const threats: string[] = [];

    try {
      const isBinary = this.isBinaryFileCategory(category);

      if (!isBinary) {
        const executableCheck = await this.checkExecutableCode(filePath);
        if (!executableCheck.safe) {
          threats.push(...executableCheck.threats);
        }

        const scriptCheck = await this.checkScriptInjection(filePath);
        if (!scriptCheck.safe) {
          threats.push(...scriptCheck.threats);
        }

        const patternCheck = await this.checkSuspiciousPatterns(filePath);
        if (!patternCheck.safe) {
          threats.push(...patternCheck.threats);
        }
      }

      if (category === "image") {
        const isValidImage = await this.validateImageIntegrity(filePath);
        if (!isValidImage) {
          threats.push("Invalid or corrupted image file");
        }
      }

      return {
        safe: threats.length === 0,
        threats,
        details: threats.length > 0 ? threats.join(", ") : undefined,
      };
    } catch (error) {
      return {
        safe: false,
        threats: ["Scan failed"],
        details: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  /**
   * Check for executable code patterns (PHP, ASP, etc.)
   */
  private async checkExecutableCode(
    filePath: string,
  ): Promise<{ safe: boolean; threats: string[] }> {
    const threats: string[] = [];

    try {
      const content = await fs.readFile(filePath, "utf-8");

      const dangerousPatterns = [
        { pattern: /<\?php/i, name: "PHP code" },
        { pattern: /<%.*%>/s, name: "ASP code" },
        { pattern: /<%@\s*Page/i, name: "ASP.NET code" },
        { pattern: /eval\s*\(/i, name: "eval() function" },
        { pattern: /exec\s*\(/i, name: "exec() function" },
        { pattern: /system\s*\(/i, name: "system() function" },
        { pattern: /passthru\s*\(/i, name: "passthru() function" },
        { pattern: /shell_exec\s*\(/i, name: "shell_exec() function" },
        {
          pattern: /base64_decode\s*\(/i,
          name: "base64_decode (potential obfuscation)",
        },
        { pattern: /assert\s*\(/i, name: "assert() function" },
        {
          pattern: /preg_replace.*\/e/i,
          name: "preg_replace with /e modifier",
        },
        {
          pattern: /\$_(?:GET|POST|REQUEST|COOKIE|SERVER)\[/i,
          name: "Superglobal access",
        },
      ];

      for (const { pattern, name } of dangerousPatterns) {
        if (pattern.test(content)) {
          threats.push(name);
        }
      }
    } catch (error) {
      return { safe: true, threats: [] };
    }

    return {
      safe: threats.length === 0,
      threats,
    };
  }

  /**
   * Check for script injection attempts
   */
  private async checkScriptInjection(
    filePath: string,
  ): Promise<{ safe: boolean; threats: string[] }> {
    const threats: string[] = [];

    try {
      const content = await fs.readFile(filePath, "utf-8");

      const scriptPatterns = [
        {
          pattern: /<script[^>]*>.*<\/script>/is,
          name: "JavaScript <script> tag",
        },
        { pattern: /javascript:/i, name: "javascript: protocol" },
        {
          pattern: /on\w+\s*=\s*["'][^"']*["']/i,
          name: "Event handler attribute",
        },
        { pattern: /<iframe[^>]*>/i, name: "iframe tag" },
        { pattern: /<embed[^>]*>/i, name: "embed tag" },
        { pattern: /<object[^>]*>/i, name: "object tag" },
        { pattern: /document\.cookie/i, name: "Cookie access" },
        { pattern: /document\.write/i, name: "document.write" },
        { pattern: /eval\s*\(/i, name: "eval() in script" },
        { pattern: /alert\s*\(/i, name: "alert() function" },
      ];

      for (const { pattern, name } of scriptPatterns) {
        if (pattern.test(content)) {
          threats.push(name);
        }
      }
    } catch (error) {
      return { safe: true, threats: [] };
    }

    return {
      safe: threats.length === 0,
      threats,
    };
  }

  /**
   * Check for suspicious file patterns
   * Note: Null byte check removed as it's normal in binary files (images, videos, etc.)
   */
  private async checkSuspiciousPatterns(
    filePath: string,
  ): Promise<{ safe: boolean; threats: string[] }> {
    const threats: string[] = [];

    try {
      const content = await fs.readFile(filePath, "utf-8");

      const suspiciousPatterns = [
        { pattern: /\.\.\//, name: "Path traversal attempt" },
        { pattern: /(?:cmd|command)\.exe/i, name: "Windows command execution" },
        {
          pattern: /\/bin\/(?:bash|sh|dash|zsh)/i,
          name: "Unix shell execution",
        },
        { pattern: /(?:wget|curl)\s+http/i, name: "Remote file download" },
        { pattern: /chmod\s+\+x/i, name: "File permission change" },
        { pattern: /rm\s+-rf/i, name: "Destructive file deletion" },
      ];

      for (const { pattern, name } of suspiciousPatterns) {
        if (pattern.test(content)) {
          threats.push(name);
        }
      }
    } catch (error) {
      return { safe: true, threats: [] };
    }

    return {
      safe: threats.length === 0,
      threats,
    };
  }

  /**
   * Validate image file integrity using Sharp
   * @param filePath - Path to image file
   * @returns true if image is valid, false otherwise
   */
  async validateImageIntegrity(filePath: string): Promise<boolean> {
    try {
      const metadata = await sharp(filePath).metadata();
      return (metadata.width ?? 0) > 0 && (metadata.height ?? 0) > 0;
    } catch {
      return false;
    }
  }

  /**
   * Check if file contains hidden data or steganography
   * Basic check - looks for unusual file size vs content ratio
   * @param filePath - Path to file
   * @param expectedSize - Expected file size based on content
   * @returns true if suspicious, false otherwise
   */
  async checkSteganography(
    filePath: string,
    expectedSize?: number,
  ): Promise<boolean> {
    try {
      const stats = await fs.stat(filePath);
      const actualSize = stats.size;

      if (expectedSize && actualSize > expectedSize * 1.5) {
        return true;
      }

      return false;
    } catch {
      return false;
    }
  }
}
